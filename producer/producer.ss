;;; Copyright (C) 2023-2026 by Massimiliano Ghilardi
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.

#!r6rs

;;;
;;; define abstract producer type: generates a finite or unlimited sequence of arbitrary values.
;;; if value #!eof is generated, it means the producer is finite and exhausted.
;;;
(library (scheme2k producer (0 9 3))
  (export
    (rename (make-producer my-make-producer))
    ;; make-producer producer producer? producer-next producer-close
    ;; for-producer in-producer hashtable-cells->producer list->producer vector->producer
    )
  (import
    (rnrs)
    (only (chezscheme)                    logbit? procedure-arity-mask record-writer void)
    (only (scheme2k bootstrap)            assert* forever fx<=?* generate-pretty-temporaries with-while-until)
    (only (scheme2k containers hashtable) hash-cursor hash-cursor-next!))


;; called internally by make-producer: create and return a producer
(define (%make-producer new next-proc close-proc)
  (assert* 'make-producer (procedure? next-proc))
  (assert* 'make-producer (logbit? 1 (procedure-arity-mask next-proc)))
  (when close-proc
    (assert* 'make-producer (procedure? close-proc))
    (assert* 'make-producer (logbit? 1 (procedure-arity-mask close-proc))))
  (new next-proc close-proc))


(define-record-type producer
  (fields
    next-proc
    close-proc)
  (protocol
    (lambda (new)
      (lambda (next-proc close-proc)
        (%make-producer new next-proc close-proc))))
  (nongenerative %producer-7c46d04b-34f4-4046-b5c7-b63753c1be39))


;; call (next-proc p) to generate one more value and return it.
;; return #!eof when values are exhausted
(define (producer-next p)
  ((producer-next-proc p) p))


;; call (close-proc p) to release any resource held by the producer.
;; return unspecified value
(define (producer-close p)
  (let ((close-proc (producer-close-proc p)))
    (when close-proc
      (close-proc p))))


;; Iterate in parallel on elements generated by generators p ..., and evaluate body ... on each element.
;; Stop iterating when any producer is exhausted, and return unspecified value.
;;
;; If no generators are specified, behave as (forever body ...)
;;
;; Does NOT close any producer.
(define-syntax for-producer
  (lambda (stx)
    (syntax-case stx ()
      ((_ () body ...)
        #'(forever body ...))
      ((_ ((var p) ...) body ...)
        (with-syntax (((tp ...) (generate-pretty-temporaries #'(p ...))))
          #'(let %for-producer ((tp p) ...)
              (let ((var (producer-next tp)) ...)
                (if (or (eof-object? var) ...)
                  (void)
                  (with-while-until
                    body ...
                    (%for-producer tp ...))))))))))


;; create and return a closure that accepts zero arguments and, at each call,
;; will return two values:
;;   either (values elem #t) i.e. the next generated value and #t,
;;   or (values #<unspecified> #f) if producer is exhausted.
(define (in-producer p)
  (assert* 'in-producer (producer? p))
  (lambda ()
    (let ((value (producer-next p)))
      (values value (not (eof-object? value))))))


;; create and return a producer that generates the cells of specified hashtable.
;; each call to (producer-next p) will return
;;  either a pair (key . value) from the hashtable
;;  or #!eof when all hashtable cells have been produced
;;
;; note: assigning the cdr of a returned pair propagates to the hashtable.
;; do NOT modify the car of any returned pair!
(define (hashtable-cells->producer ht)
  (let* ((iter (hash-cursor ht))
         (producer/hashtable ;; name shown when displaying the closure
           (lambda (p)
             (let ((cell (hash-cursor-next! iter)))
               (if cell cell (eof-object))))))
    (make-producer producer/hashtable #f)))


;; create and return a producer that generates the elements of specified list.
;; each call to (producer-next p) will return
;;  either next element from the list
;;  or #!eof when all list elements have been produced
;;
;; note: there is no way to distinguish between an #!eof element and the end of elements.
;; If you need such distinction, use `(in-list)` or some other mechanism - not a producer.
(define (list->producer l)
  (let ((producer/list ;; name shown when displaying the closure
          (lambda (p)
            (if (null? l)
              (eof-object)
              (let ((elem (car l)))
                (set! l (cdr l))
                elem)))))
    (make-producer producer/list #f)))


;; create and return a producer that generates the elements of specified vector.
;; each call to (producer-next p) will return
;;  either next element from the vector
;;  or #!eof when all vector elements have been produced
;;
;; note: there is no way to distinguish between an #!eof element and the end of elements.
;; If you need such distinction, use `(in-vector)` or some other mechanism - not a producer.
(define vector->producer
  (case-lambda
    ((v start end step)
      (assert* 'in-vector (fx<=?* 0 start end (vector-length v)))
      (assert* 'in-vector (fx>=? step 0))
      (let ((producer/vector ;; name shown when displaying the closure
              (lambda (p)
                (if (fx>=? start end)
                  (eof-object)
                  (let ((elem (vector-ref v start)))
                    (set! start (fx+ start step))
                    elem)))))
      (make-producer producer/vector #f)))
    ((v start end)
      (vector->producer v start end 1))
    ((v)
      (vector->producer v 0 (vector-length v) 1))))


) ; close library