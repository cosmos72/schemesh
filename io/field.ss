;;; Copyright (C) 2023-2026 by Massimiliano Ghilardi
;;;
;;; This library is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU Library General Public
;;; License as published by the Free Software Foundation; either
;;; version 2 of the License, or (at your option) any later version.

#!r6rs

(library (scheme2k io field (0 9 3))
  (export make-field-reader field-reader field-reader?
          field-reader-get field-reader-eof? field-reader-close field-reader-skip
          field-reader-inner)
  (import
    (rnrs)
    (only (chezscheme)                 fx1+ fx1- record-writer void)
    (only (scheme2k bootstrap)         assert*)
    (only (scheme2k containers list)   list-reverse->vector symbol-list?)
          (scheme2k io obj)
    (only (scheme2k reflect)           field))


;; Reader that wraps another "inner" reader
;; and extracts only some fields from the elements generated by it
(define-record-type (field-reader %make-field-reader field-reader?)
  (parent nested-reader)
  (fields
    rev-names  ;; vector of field names to extract, in reverse order
    cache)     ;; eq-hashtable containing rtd -> reflect-info, speeds up (field obj sym cache)
  (protocol
    (lambda (args->new)
      (lambda (inner rev-names close-inner?)
         ((args->new %field-reader-get nested-reader-inner-skip (and close-inner? nested-reader-inner-close) inner)
            rev-names (make-eq-hashtable)))))
  (nongenerative %field-reader-7c46d04b-34f4-4046-b5c7-b63753c1be42))


(define-syntax _type (identifier-syntax '<type>))


;; Create and return a field-reader that wraps a user-provided reader.
;;
;; At each call to (obj-reader-get) or (field-reader-get)
;; reads one element from the wrapped reader, then extracts only the configured fields
;; and generates a plist containing only those fields
;;
;; Mandatory arguments:
;;   inner - the reader to wrap
;;   field-names - a list of field names, they specify which fields will be selected
;;                 each field name must be either a symbol,
;;                 or a list containing two symbols (old-name new-name) - this will rename specified field
;;
;; Optional arguments:
;;   close-inner? - #f by default. if truish, closing the field-reader will also close whe wrapped "inner" reader
;;
;; Note: as per obj-reader contract, by default closing a field-reader does NOT close
;; the wrapped reader, because it is a pre-existing, borrowed resource passed to the constructor.
;;
;; If a field-reader should take ownership of the wrapped reader passed to the constructor,
;; then pass a truish value as the optional argument close-inner?
(define make-field-reader
  (case-lambda
    ((inner field-names close-inner?)
      (assert* 'make-field-reader (obj-reader? inner))
      (do ((l field-names (cdr l)))
          ((null? l))
        (let ((old-name-new-name (car l)))
          (unless (symbol? old-name-new-name)
            (assert* 'make-field-reader (fx=? 2 (length old-name-new-name)))
            (assert* 'make-field-reader (symbol? (car  old-name-new-name)))
            (assert* 'make-field-reader (symbol? (cadr old-name-new-name))))))
      (%make-field-reader
        inner
        (list-reverse->vector
          ;; always select field '<type>
          (if (memq _type field-names)
            field-names
            (cons _type field-names)))
        close-inner?))
    ((inner field-names)
      (make-field-reader inner field-names #f))))


(define (field-reader-eof? rx)
  (assert* 'field-reader-eof? (field-reader? rx))
  (obj-reader-eof? rx))


(define (field-reader-close rx)
  (assert* 'field-reader-close (field-reader? rx))
  (obj-reader-close rx))


;; return the wrapped, "inner" reader
(define (field-reader-inner rx)
  (assert* 'field-reader-inner (field-reader? rx))
  (nested-reader-inner rx))


(define (field-reader-get rx)
  (assert* 'field-reader-get (field-reader? rx))
  (obj-reader-get rx))


(define (field-reader-skip rx)
  (assert* 'field-reader-skip (field-reader? rx))
  (obj-reader-skip rx))


;; called by (field-reader-get) and (obj-reader-get)
(define (%field-reader-get rx)
  (let-values (((obj ok?) (nested-reader-inner-get rx)))
    (if ok?
      (let* ((names (field-reader-rev-names rx))
             (n     (vector-length names))
             (cache (field-reader-cache rx)))
        (let %field-reader-loop ((i 0) (plist '()))
          (if (fx>=? i n)
            (values plist #t)
            ;; extract field from obj via reflection
            (let* ((name-or-pair (vector-ref names i))
                   (old-name     (if (symbol? name-or-pair) name-or-pair (car name-or-pair)))
                   (new-name     (if (symbol? name-or-pair) name-or-pair (cadr name-or-pair)))
                   (value        (field obj old-name cache (void))))
                (%field-reader-loop
                  (fx1+ i)
                  (if (eq? (void) value)
                    ;; (void) means field has unknown value => omit it
                    plist
                    (cons new-name (cons value plist))))))))

      ;; inner reader is exhausted
      (values obj ok?))))


;; customize how "field-reader" objects are printed
(record-writer (record-type-descriptor field-reader)
  (lambda (rx port writer)
    (put-string port "#<field-reader")
    (put-string port (if (obj-reader-eof? rx) " eof (" " ok ("))
    (let* ((names (field-reader-rev-names rx))
           (n     (vector-length names)))
      (do ((i (fx1- n) (fx1- i)))
          ((fx<? i 0))
        (writer (vector-ref names i) port)
        (unless (fxzero? i)
          (put-char port #\space))))
    (put-string port ")>")))

) ; close library
