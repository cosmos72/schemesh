;;; Copyright (C) 2023-2026 by Massimiliano Ghilardi
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.

#!r6rs

;; this file should be included only by file io/obj/obj.ss


;; Reader that wraps another "inner" reader
;; and can discard some of the elements generated by it
;; by calling a user-defined predicate procedure.
(define-record-type (filter-reader %make-filter-reader filter-reader?)
  (parent nested-reader)
  (fields
    pred   ;; procedure for deciding whether to pass or discard elements generated by inner reader
    cache) ;; eq-hashtable containing rtd -> reflect-info, speeds up (field obj sym cache)
  (protocol
    (lambda (args->new)
      (lambda (inner pred close-inner?)
         ;; there's no optimized mechanism to skip an element:
         ;; we must read one or more elements from wrapped reader,
         ;; then sequentially call pred on each one
         ;; until either (pred element cache) returns truish, or wrapped reader is exhausted
         ((args->new %filter-reader-get #f (and close-inner? nested-reader-inner-close) inner)
            pred (make-eq-hashtable)))))
  (nongenerative %filter-reader-7c46d04b-34f4-4046-b5c7-b63753c1be42))


;; Create and return a filter-reader that wraps another "inner" reader.
;;
;; At each call to (reader-get) or (filter-reader-get)
;; reads one element from the wrapped reader, then checks value returned by (pred element):
;;   if truish, returns the element unchanged i.e. passes it
;;   otherwise discards the element and iterates: reads another element from the wrapped reader,
;;     and processes it again with (pred element) etc, possibly discarding multiple elements.
;;
;; Note: as per reader contract, by default closing a filter-reader does NOT close
;; the wrapped reader, because it is a pre-existing, borrowed resource passed to the constructor.
;;
;; If a filter-reader should take ownership of the wrapped reader passed to the constructor,
;; then pass a truish value as the optional argument close-inner?
(define make-filter-reader
  (case-lambda
    ((inner pred close-inner?)
      (assert* 'make-filter-reader (reader? inner))
      (assert* 'make-filter-reader (procedure? pred))
      (let* ((pred-arity-mask        (bitwise-and 6 (procedure-arity-mask pred)))
             (pred-accepts-one-arg?  (not (fxzero? (fxand 2 pred-arity-mask))))
             (pred-accepts-two-args? (not (fxzero? (fxand 4 pred-arity-mask)))))
        (assert* 'make-filter-reader (or pred-accepts-one-arg? pred-accepts-two-args?))
        (%make-filter-reader
          inner
          (if pred-accepts-two-args?
             pred
             (lambda (obj cache) (pred obj)))
          close-inner?)))
    ((inner pred)
      (make-filter-reader inner pred #f))))


;; return the wrapped, "inner" reader
(define (filter-reader-inner rx)
  (assert* 'filter-reader-inner (filter-reader? rx))
  (nested-reader-inner rx))



;; called by (reader-get) (reader-skip)
(define (%filter-reader-get rx)
  (let-values (((obj ok?) (nested-reader-inner-get rx)))
    (cond
      ((not ok?) ;; inner reader is exhausted
        (values obj ok?))
      ((not ((filter-reader-pred rx) obj (filter-reader-cache rx)))
        ;; pred tells to discard obj => iterate
        (%filter-reader-get rx))
      (else
        (values obj ok?)))))
