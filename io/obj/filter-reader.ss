;;; Copyright (C) 2023-2026 by Massimiliano Ghilardi
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.

#!r6rs

;; this file should be included only by file io/obj/obj.ss

(define-record-type (filter-reader %make-filter-reader filter-reader?)
  (parent obj-reader)
  (fields
    inner  ;; wrapped reader
    pred   ;; procedure for deciding whether to pass or discard elements generated by inner reader
    cache) ;; eq-hashtable containing rtd -> record-info, speeds up (field obj sym cache)
  (protocol
    (lambda (args->new)
      (lambda (inner pred close-inner?)
         ;; there's no optimized mechanism to skip an element:
         ;; we must read one or more elements from wrapped reader,
         ;; then sequentially call pred on each one
         ;; until either (pred element cache) returns truish, or wrapped reader is exhausted
         ((args->new %filter-reader-get #f (and close-inner? %filter-inner-close))
            inner pred (make-eq-hashtable)))))
  (nongenerative %filter-reader-7c46d04b-34f4-4046-b5c7-b63753c1be41))


;; Create and return a filter-reader that wraps a user-provided reader.
;;
;; At each call to (obj-reader-get) or (filter-reader-get)
;; reads one element from the wrapped reader, then checks value returned by (pred element):
;;   if truish, returns the element unchanged i.e. passes it
;;   otherwise discards the element and iterates: reads another element from the wrapped reader,
;;     and processes it again with (pred element) etc, possibly discarding multiple elements.
;;
;; Note: as per obj-reader contract, by default closing a filter-reader does NOT close
;; the wrapped reader, because it is a pre-existing, borrowed resource passed to the constructor.
;;
;; If a filter-reader should take ownership of the wrapped reader passed to the constructor,
;; then pass a truish value as the optional argument close-inner?
(define make-filter-reader
  (case-lambda
    ((inner pred close-inner?)
      (assert* 'make-filter-reader (obj-reader? inner))
      (assert* 'make-filter-reader (procedure? pred))
      (let* ((pred-arity-mask        (bitwise-and 6 (procedure-arity-mask pred)))
             (pred-accepts-one-arg?  (not (fxzero? (fxand 2 pred-arity-mask))))
             (pred-accepts-two-args? (not (fxzero? (fxand 4 pred-arity-mask)))))
        (assert* 'make-filter-reader (or pred-accepts-one-arg? pred-accepts-two-args? ))
        (%make-filter-reader
          inner
          (if pred-accepts-two-args?
             pred
             (lambda (obj cache) (pred obj)))
          close-inner?)))
    ((inner pred)
      (make-filter-reader inner pred #f))))


(define (filter-reader-eof? rx)
  (assert* 'filter-reader-eof? (filter-reader? rx))
  (obj-reader-eof? rx))


(define (filter-reader-close rx)
  (assert* 'filter-reader-close (filter-reader? rx))
  (obj-reader-close rx))


(define (filter-reader-get rx)
  (assert* 'filter-reader-get (filter-reader? rx))
  (obj-reader-get rx))


(define (filter-reader-skip rx)
  (assert* 'filter-reader-skip (filter-reader? rx))
  (obj-reader-skip rx))


;; called by (filter-reader-get) (filter-reader-skip)
;; and by (obj-reader-get) (obj-reader-skip)
(define (%filter-reader-get rx)
  (let-values (((obj ok?) (obj-reader-get (filter-reader-inner rx))))
    (cond
      ((not ok?) ;; inner reader is exhausted
        (values obj ok?))
      ((not ((filter-reader-pred rx) obj (filter-reader-cache rx)))
        ;; pred tells to discard obj => iterate
        (%filter-reader-get rx))
      (else
        (values obj ok?)))))


;; called by (filter-reader-close) and (obj-reader-close) if close-inner? passed to constructor is truish
(define (%filter-inner-close rx)
  (obj-reader-close (filter-reader-inner rx)))
